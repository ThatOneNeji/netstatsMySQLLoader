/**
 * @typedef {Object} queueBase
 * @property {string} consumeBaseName This is the base queue name to use for consume
 * @property {string} publishBaseName This is the base queue name to use for publish
 * @description This object contains the queue information for the message broker subsystem
 */
/**
 * @typedef {Object} loggingConfiguration
 * @property {string} appenders Appenders serialise log events to some form of output
 * @property {string} categories The category (or categories if you provide an array of values) that will be excluded from the appender.
 * @description This defines the way the logger works
 */
/**
 * @typedef {Object} loggingOptions
 * @property {string} level The level of logging to use
 * @property {array} areas This is the various areas used for getLogger
 * @property {string} owner Application name
 * @description This object contains the configuration information for the logging subsystem
 */
/**
 * @typedef {object} ApplicationConfiguration
 * @property {loggingConfiguration} logger This defines the way the logger works
 * @property {loggingOptions} logging This object contains the configuration information for the logging subsystem
 * @property {messageBrokerServerSettings} messagebrokers This object contains the configuration information for the message broker sub system
 * @property {queueBase} queues This object contains the queue information for the message broker subsystem
 * @description Configuration from config.json
 */
/**
 * @property {ApplicationConfiguration} appConfig
 */
let appConfig;

/* Load internal libraries */
const Logger = require('commonfunctions').Logger;
// const NejiUtils = require('commonfunctions').NejiUtils;
// const Common = new NejiUtils();
// const xmlParser = require('xml2json');
// const util = require('util');

const MessageBroker = require('commonfunctions').MessageBroker;
const messagebroker = new MessageBroker();
const fs = require('fs');
const moment = require('moment');
const mysql = require('mysql2');

let Logging;

/**
 * @function bail
 * @param {*} err String/object from sender
 * @description We use this to exit out of the application if fatal
 */
function bail(err) {
    console.error(err);
    process.exit(1);
}


/**
 * @function loadConfigurationFile
 * @description Reads configuration from local file
 */
function loadConfigurationFile() {
    try {
        appConfig = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    } catch (err) {
        bail(err);
    }
}

/**
 * @function initialiseApplication
 * @description Starts up the application
 */
function initialiseApplication() {
    loadConfigurationFile();
    Logging = new Logger(appConfig.logging);
}

/**
 * Initialise the application
 */
initialiseApplication();

process.stdin.resume(); // so the program will not close instantly

/**
 *
 * @param {*} options
 * @param {*} exitCode
 * @description This function handles the exiting of the application
 */
function exitHandler(options, exitCode) {
    const msg = {
        signal: options.type,
        description: options.description,
        exitcode: exitCode
    };
    Logging.system.debug(msg);
    if (options.exit) {
        process.exit();
    }
}

// do something when app is closing
// process.on('exit', exitHandler.bind(null, { cleanup: true, type: 'ENDING', description: 'Application ending' }));
process.on('exit', (code) => {
    const msg = { cleanup: true, type: 'exit', code: code };
    Logging.system.debug('Application shut down: ' + JSON.stringify(msg));
});
// catches ctrl+c event
process.on('SIGINT', exitHandler.bind(null, { exit: true, type: 'SIGINT', description: 'SIGINT is generated by the user pressing Ctrl+C and is an interrupt' }));
// catches "kill pid" (for example: nodemon restart)
process.on('SIGUSR1', exitHandler.bind(null, { exit: true, type: 'SIGUSR1', description: 'The SIGUSR1 signal is sent to a process to indicate user-defined conditions' }));
process.on('SIGUSR2', exitHandler.bind(null, { exit: true, type: 'SIGUSR2', description: 'The SIGUSR2 signal is sent to a process to indicate user-defined conditions' }));
// catches uncaught exceptions
process.on('uncaughtException', (error) => {
    const msg = {
        exit: true,
        type: error.name,
        description: error.message,
        stack: error.stack
    };
    exitHandler.bind(null, msg);
    Logging.system.debug(msg);
    process.exit(1);
});

/**
 * @typedef {Object} messageBrokerServerSettings
 * @property {string} host Host name or address to use
 * @property {string} user Username to use
 * @property {string} password Pasword for above listed username
 * @property {string} port Port for host (optional)
 * @property {string} vhost The vhost to use (optional)
 * @property {string} active If this host should be used or not (optional)
 * @description This object contains the configuration information for the message broker sub system
 */
/**
 * @typedef {Object} messageBrokerOptions
 * @property {function} logger Logger to pass on to the messagebroker so that it can log messages
 * @property {messageBrokerServerSettings} config Configuration for the RabbitMQ server
 * @property {string} receiveQueue This is the queue to consume from
 * @property {string} receiveQueueName This is the name of the consume instance
 * @property {function} externalHandover This function is called from the message broker in order to action incoming data
 */
const messageBrokerOptions = {
    logger: Logging.messagebroker,
    config: appConfig.messagebrokers,
    receiveQueue: appConfig.queues.consumeBaseName,
    externalHandover: receiveHandler
};

/**
 * Start the message broker sub system
 */
messagebroker.init(messageBrokerOptions);

const pool = mysql.createPool({
    connectionLimit: appConfig.database.connectionLimit,
    host: appConfig.database.host,
    port: appConfig.database.port,
    user: appConfig.database.user,
    password: appConfig.database.password,
    database: appConfig.database.schema,
    multipleStatements: appConfig.database.multipleStatements || false
});

/**
 *
 * @param {string} value Value to be checked
 * @return Either the original value or else a default value
 * @description This function returns a "default" value in case the supplied 'value' is null or ''
 */
function defaultValue(value) {
    if (value === null || value === '') {
        return 'N/A';
    } else {
        return value;
    }
}

/**
 *
 * @param {integer} statusvalue Status to be parsed
 * @return Parsed status values
 * @description This function converts the integer value into readable text
 */
function parseServerStatus(statusvalue) {
    const parsedstatus = [];

    if (statusvalue & 1)
        parsedstatus.push('SERVER_STATUS_IN_TRANS');

    if (statusvalue & 2)
        parsedstatus.push('SERVER_STATUS_AUTOCOMMIT');

    if (statusvalue & 8)
        parsedstatus.push('SERVER_MORE_RESULTS_EXISTS');

    if (statusvalue & 16)
        parsedstatus.push('SERVER_QUERY_NO_GOOD_INDEX_USED');

    if (statusvalue & 32)
        parsedstatus.push('SERVER_QUERY_NO_INDEX_USED');

    if (statusvalue & 64)
        parsedstatus.push('SERVER_STATUS_CURSOR_EXISTS');

    if (statusvalue & 128)
        parsedstatus.push('SERVER_STATUS_LAST_ROW_SENT');

    if (statusvalue & 256)
        parsedstatus.push('SERVER_STATUS_DB_DROPPED');

    if (statusvalue & 512)
        parsedstatus.push('SERVER_STATUS_NO_BACKSLASH_ESCAPES');

    if (statusvalue & 1024)
        parsedstatus.push('SERVER_STATUS_METADATA_CHANGED');

    if (statusvalue & 2048)
        parsedstatus.push('SERVER_QUERY_WAS_SLOW');

    if (statusvalue & 4096)
        parsedstatus.push('SERVER_PS_OUT_PARAMS');

    if (statusvalue & 8192)
        parsedstatus.push('SERVER_STATUS_IN_TRANS_READONLY');

    if (statusvalue & 16384)
        parsedstatus.push('SERVER_SESSION_STATE_CHANGED');

    return parsedstatus.join(',');
}

/**
 *
 * @param {*} data String or object to write to disk
 * @param {string} service Name of service that failed
 * @param {string} sql SQL statement
 * @param {boolean} nonsql If the data is not sql
 * @description This function writes the 'data' variable to a file
 */
function writeData(data, service, sql = '') {
    let filename = moment().format('YYYYMMDDHH') + '_' + service + '.sql';
    let datastring;
    let filemessage;
    if (data.sql) {
        if (data.sql.constructor === String) {
            datastring = data.sql.replace(/;/g, ';\r\n');
        } else {
            datastring = JSON.stringify(data.sql) + '\r\n';
        }

        filemessage = '/* ' + moment().format('YYYY/MM/DD HH:mm:ss.SSS') + ' */ ' + '\r\n' + datastring;
        fs.appendFile(filename, filemessage, (err) => {
            if (err)
                Logging.fs.error(err);
        });
    }
    if (sql) {
        if (sql.constructor === String) {
            datastring = sql.replace(/;/g, ';\r\n');
        } else {
            datastring = JSON.stringify(sql) + '\r\n';
        }

        filemessage = '/* ' + moment().format('YYYY/MM/DD HH:mm:ss.SSS') + ' */ ' + '\r\n' + datastring;
        fs.appendFile(filename, filemessage, (err) => {
            if (err)
                Logging.fs.error(err);
        });
    }
}

/**
 *
 * @param {object} result Result object to be used
 * @return Formatted string of the keys/values from the result varible
 * @description This function converts and formats the result variable
 */
function buildResultString(result) {
    let parsedresult = '';
    Object.keys(result).sort().forEach(function(key) {
        if (key.constructor === String) {
            if (key == 'serverStatus') {
                parsedresult += '"' + key + ':(' + result[key] + ')' + parseServerStatus(result[key]) + '" ';
            } else {
                parsedresult += '"' + key + ':' + defaultValue(result[key]) + '" ';
            }
        }
    });
    return parsedresult;
}

/**
 *
 * @param {string} servicename This is the name of the service
 * @param {*} results This varible contains the various status fields
 * @description This function uses the data from the results variable to create log messages
 */
function parseSQLResults(servicename, results) {
    if (results.constructor === Array) {
        results.forEach(result => {
            Logging.mysql.debug('Service: "' + servicename + '" results: ' + buildResultString(result));
        });
    } else {
        Logging.mysql.debug('Service: "' + servicename + '" results: ' + buildResultString(results));
    }
}

/**
 *
 * @param {*} payload This object contains the data from the message broker
 * @return The SQL statement
 * @description This function uses the data from the results variable to create log messages
 */
function checkPayload(payload) {
    if (payload.sql) {
        return payload.sql
    }
    if (payload.content.sql) {
        return payload.content.sql
    }
    if (payload.content.name) {
        return payload.content.name
    }
    return '';

}

function getService(payload) {
    if (payload.subscription) {
        // return payload.subscription;
        return payload.subscription.toLowerCase();
    }
    if (payload.service) {
        // return payload.service;
        return payload.service.toLowerCase();
    }
    return 'unknown';
}

/**
 * @typedef {Object} mysqldataobject
 * @property {string} service Area or table name
 * @property {string} sql SQL statement to action
 * @property {string} caid Hash value of the original object. This is used to track the message.
 * @property {number} qtime Queue post time
 * @description This object contains the fields needed for the loader to work
 */

/**
 * @typedef {Object} queuemessageobject
 * @property {object} fields Information regarding the routing
 * @property {object} properties Properties of the message
 * @property {buffer} content The data that was posted on thw queue
 * @description This object contains the data from the message broker
 */
/**
 *
 * @param {queuemessageobject} queuemessage This object contains the data from the message broker
 * @return Send a message back to ack the message
 * @description This function uses the data from the results variable to create log messages
 */
function receiveHandler(queuemessage) {
    let MySQLJSONPayload = JSON.parse(queuemessage.content.toString());
    let sql = checkPayload(MySQLJSONPayload);
    return new Promise(function(resolve, reject) {
        // {"protocol":"mysql","subscription":"dev_tbl_base_snmp_mtxrWlAp_raw","area":"dev_mcnms/data","content":{"name":"UPDATE dev_tbl_base_snmp_mtxrWlAp_raw SET processed = 'y' WHERE ldate > now() - INTERVAL 120 SECOND AND ldate < now() - INTERVAL 30 SECOND AND processed = 'n';"},"interval":1,"host":"172.16.119.35","groupname":"TESTING MySQL Servers","parameters":{},"stime":1654961940027,"etime":1654961970027,"rdate":"2022/06/11 17:39:00","lifespan":30,"service":"cron","caid":"33f284a975327bdfcca7bb3cd761e1f45fb8aff97338cafabf1797da3cb2e383","qtime":1654961940034}
        // {"service":"dev_tbl_base_snmp_hrdevice_raw","sql":"INSERT INTO dev_tbl_base_snmp_hrdevice_raw (rdate, host, hrdeviceindex, hrdevicetype, hrdevicedescr, hrdeviceid) VALUES ('2022-06-11 12:45:00','10.0.70.251', '786432', '.1.3.6.1.2.1.25.3.1.12', 'Guessing that there''s a floating point co-processor', 'ccitt.0')  ON DUPLICATE KEY UPDATE processed = 'n' ,hrdeviceindex = '786432',hrdevicetype = '.1.3.6.1.2.1.25.3.1.12',hrdevicedescr = 'Guessing that there''s a floating point co-processor',hrdeviceid = 'ccitt.0' ;","caid":"2a79ca38ce294567fd3fddd80cd632914bf6713d531d27b63a284a3ec7fa55c0","qtime":1654961970048}
        pool.query(sql, function(error, results, fields) {
            if (error) {
                Logging.mysql.error('Service: "' + getService(MySQLJSONPayload) + '" results: ' + buildResultString(error));
                writeData(error, getService(MySQLJSONPayload), sql);
                if (fields) {
                    Logging.mysql.debug(fields);
                }
                reject(error);
            } else {
                parseSQLResults(getService(MySQLJSONPayload), results);
            }
        });

        resolve(true);
    }).catch(function(error) {
        Logging.mysql.error(error);
        writeData(error, getService(MySQLJSONPayload), sql);
    });
}